TStools说明书
周骋
最后更新：2011年01月12日
%! target : html
%! style : fancy.css
%! encoding: utf-8
%! options : --toc --enum-title

=初识TStools=

++TStools的诞生++
搞数字电视编解码就要跟码流打交道，分析码流的过程中我一直希望把一些繁琐的操作自动化。
虽然公司有码流分析仪，但几个人共用一个仪器总是不方便，并且有些功能码流分析仪也不支持。

2009年初，我开发的H.264编码器出现PCR异常，非常需要连续记录PCR值以便分析其变化规律。
码流分析仪只关注像PCR间隔和PCR抖动这样的指标，不能连续输出PCR值。
于是TStools的最初版本诞生了——SVN的日志记录了它版本化的日子：4月1日。
当时有tsana、ts2es和tsflt三个工具，因此叫TStools（TS工具集）——是不是有点BusyBox的味道？
- tsana分析TS包头，如果有PCR就提取并打印出来；
- ts2es借用了同事给的一个函数，实现TS到ES的转换（试了一下，好像功能不对）；
- tsflt可以将码流中指定PID的包打印出来。


第2季度，我负责在公司的EMR平台上开发IP发送功能。
代码缺陷和网络问题都会导致丢包，这种小概率事件可能一夜只发生一次，甚至仅在早上上班的时候出现。
因此准确地捕捉丢包事件，对调试工作会有很大帮助。
但是码流分析仪的软件夜里可能会死机，导致拷机实验失败。
因此我在tsana工具中增加了UDP接收模块，跟踪指定PID的CC值，一旦不连续就把系统时间和CC情况打印出来。
如果想同时分析所有PID的丢包情况就要复杂一些了：
- tsana要同时跟踪每一种PID的CC数值——需要建立一个链表记录所有出现过的PID；
- tsana要知道每个PID的类型——空包和PCR包的CC值是不变的。


即使是完整的实现丢包检测都必须做PSI分析，因此我在这个简单的基础上停下来，开始考虑TStools的架构。

++TStools的基本思路++

+++算法与界面分离+++
码流分析产生的数据结果很复杂，如何展现给用户是个重要的问题。
针对各种数据特点，图形界面的码流分析软件会使用列表、树、波形图等各种控件展现。
鄙人没有太多艺术细胞，若搞出一个丑丑的图形界面，不仅别人看不上眼，自己用着也难受。
另外搞图形界面需要花大量精力在界面技术上，我更想把精力都用在码流分析算法上。
因此作为一个懒人，我选择文本界面，只是简单地把分析结果打印出来。

[1.jpg]

这里必须提一下csv文件格式，说它是一种文件格式实在是搞复杂了，
它就是一种文本方式的数据文件，唯一的要求是数据之间用英文逗号隔开。
但是因为这样的规定，像Excel这样的数据处理软件可以直接打开它，开展进一步的数据分析，甚至以图形方式展现数据。
因此csv文件格式是数据能被进一步分析的重要形式，本项目的大部分数据输出都采用逗号分隔，以便保存为csv文件。

虽然我不做图形界面，但是也不想拒绝别人为本项目开发其它形式的界面。
因此本项目的分析代码与文本界面位于不同的模块——如果分析模块封装的很好，别人是可以直接拿来开发界面的。

由于分析模块和文本界面仅处理数据，不涉及任何平台相关的内容，因此项目的可移植性非常好。
我不想把这样的项目局限在Windows平台下，因此在Windows下坚持基于cygwin环境开发，
目前的TStools源代码可以直接在Linux环境下编译运行。

+++数据文本化+++
为了同时支持离线分析（TS文件）和在线分析（TS over IP），tsana曾经根据参数格式（文件名/URL地址）选择不同的输入模块。
当时我还把UDP模块的接口封装成文件系统接口的样子，以便tsana能用同样的函数打开两种源。
后来我发现可能的输入方式不止这两种，RTP方式、HTTP方式也可以传输TS流，甚至只要开发一个小盒子就可以支持ASI输入。
难道每增加一种输入方式就要改一次tsana？在shell中，这个问题有更好的解决办法。

Unix下有一个叫做“过滤器”的概念：
每个工具处理stdin（标准输入）传入的内容，产生的结果写给stdout（标准输出），出现的错误写入stderr（标准错误）。
多个这样的过滤器可以用“管道”连接起来，完成复杂的任务。
如果把tsana设计成一个过滤器，仅处理从stdin输入的码流，借助管道就可以支持任意形式的输入。

[2.jpg]

采用这个方案需要解决一个衍生问题：二进制形式的TS数据以什么样的格式在管道间传输？
二进制数据由于可读性差，需要特殊的同步协议，在Unix世界中被严重鄙视。
大部分过滤器都采用文本格式，一行行地（每行同步一次）传递数据。
因此我设计了bincat工具，把二进制形式的TS文件读出来，以文本方式一包一行地发给stdout；
又设计了ipcat工具，把TS over IP中的UDP包拆开成数个TS包，以文本方式一包一行地发给stdout；
而tsana只是简单的从stdin中一包一行的接收TS包就可以了，它不需要知道是谁在给它码流。
以后如果要增加新的输入形式就写一个xxcat就行了，tsana不需要改代码重新编译。

解释一下cat，这是unix下一个非常普通的工具，它把文本文件读出来输出到stdout。
因为cat不支持二进制文件，所以我仿照它写了一个tscat，后来扩展了其功能不再限定TS文件，于是形成了bincat。

规定用文本形式一行传送一个TS包还不够明确，具体这一行是什么格式呢？
考虑到阅读方便，TS包中的188（或204）个字节之间要有分隔符，
前面提到的英文逗号自然可以，但是过于密集的逗号还是影响阅读，因此用单个空格做分隔符更好。
于是每个TS包变成了这样的文本行：“?? ?? ?? ... ?? \n”，每个字节变成了3个可显字符。
如果用户需要，bincat允许指定任何字符用作间隔符，而tsana也允许间隔处出现任何[0-9A-Fa-f]范围之外的字符。
如果bincat中使用“printf("%02X ", x)”把数据转换成文本形式，效率就太低了。
对于这样一个固定的转换，使用查表法可以克服TS数据文本化的唯一弊端——效率问题。

当TS包变成文本行时，我忽然发现除了tsana，还可以直接使用Unix下的很多工具直接处理bincat的输出：
可以用grep过滤出指定PID的TS包，可以用sed修改某些数据......只要你会使用强大的正规表达式。
最后一个问题：这些工具的输出还是文本格式，如果想回到二进制格式呢？
于是我设计了tobin工具，把符合上述格式的文本转换回二进制文件（阴阳平衡很重要）。
当tobin出现时，我发现用“ipcat + tobin”立刻就能实现实时流的录制功能（用VLC录流是需要一点技巧的）。
Unix的小工具思想太强大了！

[3.jpg]

=使用TStools=
Hi! This is my test document.
Its content will end here.

=深入了解TStools=
Hi! This is my test document.
Its content will end here.
[周骋 zhoucheng@tsinghua.org.cn]
